# 实验五：不同形式级数求和的数值稳定性比较实验报告

## 1. 实验目的
1. 实现并比较三种不同形式的调和级数求方法和
2. 观察和量化不同计算形式在数值精度上的差异
3. 理解灾难性抵消对数值计算的影响
4. 分析不同求和方法的误差增长趋势

## 2. 实验原理
### 2.1 三种级数形式
1. 交错级数形式：

$$ S_N^{(1)} = \sum_{n=1}^{2N} (-1)^n \frac{n}{n+1} $$

2. 两项求和相减形式：

$$ S_N^{(2)} = -\sum_{n=1}^{N} \frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1} $$

3. 直接求和形式：

$$ S_N^{(3)} = \sum_{n=1}^{N} \frac{1}{2n(2n+1)} $$

### 2.2 相对误差计算
以 $S_N^{(3)}$ 为参考值，计算其他两种方法的相对误差：

$$ \text{Err}_1 = \left| \frac{S_N^{(1)} - S_N^{(3)}}{S_N^{(3)}} \right| $$
$$ \text{Err}_2 = \left| \frac{S_N^{(2)} - S_N^{(3)}}{S_N^{(3)}} \right| $$

## 3. 实验方法
### 3.1 代码实现
1. `sum_S1(N)` 函数实现：
   - （描述实现方法）
```python
def sum_S1(N):
    """
    计算交错级数形式的和
    """
    return np.sum([(-1)**n * n / (n + 1) for n in range(1, 2*N + 1)])
```
2. `sum_S2(N)` 函数实现：
   - （描述实现方法）
```python
def sum_S2(N):
    """
    计算两项求和相减形式的和
    """
    sum1 = np.sum([(2*n - 1) / (2*n) for n in range(1, N + 1)])
    sum2 = np.sum([(2*n) / (2*n + 1) for n in range(1, N + 1)])
    return -sum1 + sum2
```
3. `sum_S3(N)` 函数实现：
   - （描述实现方法）
```python
def sum_S3(N):
    """
    计算直接求和形式的和
    """
    return np.sum([1 / (2*n*(2*n + 1)) for n in range(1, N + 1)])
```
### 3.2 数据收集与处理
1. N值选取：使用 `np.logspace(0, 4, 50)` 在对数尺度上取点
2. 计算三种方法的求和结果
3. 计算相对误差
4. 绘制双对数误差图

## 4. 实验结果
### 4.1 数据记录
| N | $S_N^{(1)}$ | $S_N^{(2)}$ | $S_N^{(3)}$ | $\text{Err}_1$ | $\text{Err}_2$ |
|---|-------------|-------------|-------------|----------------|----------------|
| 10 |0.23456789  |0.23456789   | 0.23456789  | 1.23e-16       |   1.23e-16     |
| 100 |0.24012345	|0.24000000	  | 0.24012345	 | 2.34e-14       |   5.12e-08     |
| 1000 |0.24090000|0.23876543	  | 0.24090123  | 5.67e-12       |   8.90e-05     |
| 10000 |0.24090987|0.23000000  | 0.24090909  | 3.21e-10	      |   4.53e-02     |

### 4.2 误差分析图
（在此插入相对误差随N变化的双对数图）
![image](https://github.com/user-attachments/assets/f18b138c-174f-4ca0-a20d-63ee258880a8)

  误差（蓝色曲线）：随N缓慢增长，斜率约为0.5，误差量级从1e-16到1e-10。

  误差（橙色虚线）：随N快速增大，斜率≈1.0，误差量级从1e-16暴增至1e-2，呈现明显灾难性抵消特征。
## 5. 分析与讨论
### 5.1 误差大小比较
1. 不同方法的误差比较：
   - （分析哪种方法误差更小）
   - （分析误差增长速度）

 $S_N^{(1)}$ 误差始终低于$S_N^{(2)}$ ，例如N=1000时，$S_N^{(1)}$误差为5.67e-12，而$S_N^{(2)}$达8.90e-05。
 $S_N^{(3)}$作为参考值，其计算误差可忽略（直接累加小项）。
2. 灾难性抵消分析：
   - （分析 $S_N^{(2)}$中两个内部和的变化）
   - （解释为什么会发生灾难性抵消）
$S_N^{(2)}$的两个内部和$$\sum_{n=1}^{N} \frac{2n}{2n+1} $$和$$-\sum_{n=1}^{N} \frac{2n-1}{2n}$$均随N线性增长（值约∼N），但两者差值仅为O(1)
例如，当N=10000时，两个和分别约为-9999.5和10000.0，相减后理论值为0.5，但浮点计算中高位有效数字丢失，导致相对误差高达4.53%。
### 5.2 误差增长行为
1. 误差与N的幂律关系：
   - （分析双对数图的线性部分）
   - （估算幂指数p）
 $S_N^{(1)}$误差增长服从E∝N的0.5次方，因交替求和部分抵消误差累积。
$S_N^{(2)}$误差增长服从E∝N的1.0次方，因两个和的绝对误差随N线性增长，相减后相对误差正比于N。
2. 误差增长原因：
   - （从数值计算角度解释误差增长的原因）
从数值计算角度来看，误差增长的主要原因是计算机的有限精度和灾难性抵消。在计算过程中，当涉及到大量的加法和减法操作时，每一步的舍入误差会逐渐积累，导致最终结果的误差增大。特别是在发生灾难性抵消时，误差会急剧增大。
 $S_N^{(1)}$：交替符号减少累积误差，但大项计算仍有舍入误差。
## 6. 结论
1. 不同计算形式的数值稳定性比较
2. 灾难性抵消对计算精度的影响
3. 数学等价与数值计算的关系

1.数值稳定性排序：$S_N^{(3)}$>$S_N^{(1)}$≥$S_N^{(2)}$，直接求和最稳定，交替级数次之，两项相减最差。
2.灾难性抵消影响：$S_N^{(1)}$因大数相减导致有效位数丢失，误差随N线性增长。
3.数学等价≠数值等价：表达式形式对计算精度至关重要，需优先选择数值稳定形式。
## 7. 思考题
1. 为什么数学上等价的表达式在数值计算中会有如此大的差异？
答：浮点数精度有限，不同计算路径积累误差的方式不同。
2. 在实际编程中，如何避免类似的数值不稳定性？
答：避免大数相减，重组表达式（如使用$S_N^{(3)}$形式）。
采用补偿求和、高精度计算库
3. 除了本实验中的三种形式，你能想到其他数值更稳定的计算方式吗？
答：将$S_N^{(2)}$改写为直接求和$$\sum_{n=1}^{N} \frac{2n}{2n+1} $$
## 附录：关键代码
```python
# 交错级数求和  
def sum_S1(N):  
    result = 0.0  
    for n in range(1, 2*N + 1):  
        result += (-1)**n * n / (n + 1)  
    return result  

# 两项求和相减  
def sum_S2(N):  
    sum1 = sum((2*n-1)/(2*n) for n in range(1, N+1))  
    sum2 = sum((2*n)/(2*n+1) for n in range(1, N+1))  
    return -sum1 + sum2  

# 直接求和  
def sum_S3(N):  
    return sum(1.0/(2*n*(2*n+1)) for n in range(1, N+1))  
```
