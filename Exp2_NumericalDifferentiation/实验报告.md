# 实验二：数值微分的误差权衡

## 1. 实验目的
- 理解数值微分中截断误差与舍入误差的权衡关系
- 观察有限差分法计算导数时的误差变化规律
- 分析步长对数值微分精度的影响
- 确定最优步长范围

## 2. 实验方法
### 2.1 理论基础
数值微分是通过有限差分近似导数的计算方法。本实验实现了两种差分方法：
- 前向差分法: $f'(x) \approx \frac{f(x+\delta) - f(x)}{\delta}$
- 中心差分法: $f'(x) \approx \frac{f(x+\delta) - f(x-\delta)}{2\delta}$

### 2.2 测试函数
本实验使用函数 $f(x) = x(x-1)$，其解析导数为 $f'(x) = 2x - 1$。

### 2.3 实验步骤
1. 实现前向差分和中心差分函数
2. 在 $x=1$ 点计算不同步长下的数值导数
3. 计算数值导数与解析导数的相对误差
4. 绘制误差-步长关系图（对数坐标）
5. 分析最优步长和收敛阶数

## 3. 实验结果
### 3.1 数据表格
| 步长(δ) | 前向差分值 | 中心差分值 | 解析解 | 前向差分相对误差 | 中心差分相对误差 |
|---------|------------|------------|--------|------------------|------------------|
| 1.00e-02 | 1.00e-02  | 8.881784e-16| 1.0   |  1.000000e-02	| 0.000000e+00     |
| 1.00e-04 | 1.00e-04  | 1.101341e-13| 1.0    | 1.000000e-04    | 2.775558e-17     |
| 1.00e-06 | 9.3999177e-07| 2.675549e-11 | 1.0| 1.000089e-06    | 2.775558e-17     |
| 1.00e-08 | 3.922529e-09 | 5.263561e-10 | 1.0| 2.220446e-08    | 5.551115e-17     |
| 1.00e-10 | 8.284037e-08 | 8.274037e-08 | 1.0| 8.274037e-06    | 8.274037e-06     |
| 1.00e-12 | 8.890058e-05 | 3.338943e-05 | 1.0| 8.890059e-05    | 1.110223e-16     |
| 1.00e-14 | 7.992778e-04 | 7.992778e-04 | 1.0| 1.110223e-02    | 2.220446e-16     |


### 3.2 误差-步长关系图
（在此插入误差-步长关系图，并简要说明图中观察到的现象）
![image](https://github.com/user-attachments/assets/50a76e21-cd27-4ba2-b26b-b4dc50a44328)

从图中可以观察到，随着步长的减小，前向差分和中心差分的误差都先减小后增大。在步长较小时，舍入误差开始主导，导致误差增大。中心差分的误差在大部分步长范围内都小于前向差分，说明中心差分的精度更高。

## 4. 分析与讨论
### 4.1 误差来源分析
数值微分中存在两种主要误差来源：
- **截断误差**：由于使用有限差分近似导数定义引入的误差，通常随步长减小而减小
- **舍入误差**：由于计算机浮点数表示的有限精度引入的误差，通常随步长减小而增大

（分析实验中观察到的截断误差和舍入误差的表现）
截断误差：大δ时，前向差分（O(δ)）误差明显大于中心差分（O(δ²)）。
舍入误差：δ过小时，浮点运算中函数值的微小差异被放大，导致误差反向增长。例如，δ=1e-14时，前向差分的相对误差高达1.1%。
### 4.2 前向差分与中心差分的比较
（比较两种方法的精度差异，并解释原因）
精度：中心差分在相同δ下的误差显著低于前向差分。例如，δ=1e-4时，中心差分误差为2.78e-17，接近机器精度。

原因：中心差分截断误差阶数更高，对二次函数可精确计算导数（理论误差为零），实际误差仅由舍入误差贡献。
### 4.3 最优步长分析
（分析实验中观察到的最优步长，并解释为什么存在最优步长）
前向差分最优δ≈1e-8：截断误差与舍入误差平衡点。
中心差分最优δ≈1e-6：更高阶方法允许更小δ后才出现舍入误差累积。
存在性：总误差为截断误差和舍入误差之和，二者竞争导致误差曲线存在最小值。
### 4.4 收敛阶数分析
（分析两种方法的收敛阶数，并与理论预期进行比较）
中间区域斜率：前向差分≈1.0，中心差分≈2.0，与理论一致。
异常点：δ=1e-10时，前向差分误差突增，因舍入误差占比超过截断误差。
## 5. 实验结论
（总结本实验的主要发现，特别是关于误差权衡、最优步长和不同差分方法的优缺点）
1.数值微分需权衡截断误差与舍入误差，最优步长使二者平衡。
2.中心差分精度显著优于前向差分，但对舍入误差更敏感。
3.前向差分最优δ约1e-8，中心差分约1e-6，与函数形式和计算精度相关。
4.实际应用中应通过类似实验确定最优步长，避免盲目减小δ。
## 附录：核心代码片段
```python
# 前向差分法实现
def forward_diff(f, x, delta):
    return (f(x + delta) - f(x)) / delta

# 中心差分法实现
def central_diff(f, x, delta):
    return (f(x + delta) - f(x - delta)) / (2 * delta)

# 定义测试函数
def f(x):
    return x * (x - 1)

# 定义解析导数
def df(x):
    return 2 * x - 1

# 定义步长
deltas = np.array([1.0e-2, 1.0e-4, 1.0e-6, 1.0e-8, 1.0e-10, 1.0e-12, 1.0e-14])
x = 1
analytical_solution = df(x)

# 计算误差
forward_errors = []
central_errors = []
for delta in deltas:
    forward_value = forward_diff(f, x, delta)
    central_value = central_diff(f, x, delta)
    forward_error = np.abs((forward_value - analytical_solution) / analytical_solution)
    central_error = np.abs((central_value - analytical_solution) / analytical_solution)
    forward_errors.append(forward_error)
    central_errors.append(central_error)

# 绘制误差 - 步长关系图
import matplotlib.pyplot as plt
plt.loglog(deltas, forward_errors, label='Forward Difference')
plt.loglog(deltas, central_errors, label='Central Difference')
plt.xlabel('Step Size (δ)')
plt.ylabel('Relative Error')
plt.title('Error vs Step Size')
plt.legend()
plt.grid(True)
plt.show()
```
