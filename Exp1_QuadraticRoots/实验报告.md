# 实验1: 二次方程求根的稳定性
007雷翊烜
## 1. 实验目的
1. 探究二次方程求根过程中可能出现的数值不稳定问题
2. 分析不同求根公式在不同参数条件下的误差表现
3. 理解数值计算中精度损失的原因及改进方法

## 2. 实验方法
1. 使用公式法求解二次方程 $ax^2+bx+c=0$ 的根
2. 实现两种不同的求根公式：
   - 标准求根公式： $x = \frac{-b \pm \sqrt{b^2-4ac}}{2a}$
   - 替换求根公式： $x = {2c\over-b\mp\sqrt{b^2-4ac}}$
3. 比较两种方法在不同参数条件下的数值稳定性，找到一种稳定的求根方法。

## 3. 实验结果
展示计算得到的主要数据、图表和观察现象。
   ![image](https://github.com/user-attachments/assets/40b2d5a4-c783-42e3-b712-c7225a2c266a)
方程 1x^{2}+2x + 1 = 0
 
- 方法1（标准公式）：x_1 = -1.0，x_2 = -1.0 。标准求根公式在这种系数常规的简单方程下，能准确求解。
- 方法2（替代公式）：x_1 = -1.0，x_2 = -1.0 。替代公式同样有效，两种公式在此处结果一致，因为方程系数没有引发数值稳定性问题。
- 方法3（稳定求根程序）：x_1 = -1.0，x_2 = -1.0 。稳定求根程序也能正确计算，说明在简单情形下，各方法都可靠。
 
方程 1x^{2}+100000.0x + 1 = 0
 
- 方法1（标准公式）：x_1 = -0.00001000003385，x_2 = -99999.99998999996615 。b值远大于a和c ，标准公式出现“灾难性抵消” ，$ -b + \sqrt{b^{2}-4ac}$ 计算时有效数字丢失，导致结果误差较大。
- 方法2（替代公式）：x_1 = -0.00001000000001，x_2 = -99999.966146435879637 。替代公式一定程度缓解数值问题，但仍有误差。
- 方法3（稳定求根程序）：x_1 = -99999.99998999996615，x_2 = -0.00001000000001 。稳定求根程序通过算法调整，避免了“灾难性抵消”，结果更精确。
 
方程 0.001x^{2}+1000x + 0.001 = 0
 
- 方法1（标准公式）：x_1 = -0.00000099999989425，x_2 = -999999.99998999992386 。标准公式受“灾难性抵消”影响，精度不足。
- 方法2（替代公式）：x_1 = -0.000001000000000，x_2 = -1000010.575512505718507 。替代公式有改善，但仍存在偏差。
- 方法3（稳定求根程序）：x_1 = -999999.99998999992386，x_2 = -0.000001000000000 。稳定求根程序利用优化算法，克服数值不稳定，结果更可靠。
 
总体而言，标准求根公式在系数特殊（b^{2}\gg|4ac| ）时易出现数值不稳定；替代公式有一定改善作用；稳定求根程序能更好避免“灾难性抵消”，在各种情况下都能得到更准确、可靠的结果。


## 4. 分析与讨论
1. 分析两种方法在不同参数条件下的误差表现
2. 讨论数值计算中可能出现的问题及改进方法
一.标准求根公式（方法1）
 
- 简单方程情况（如1x^{2}+2x + 1 = 0 ）
此时系数常规，b^{2}-4ac 计算结果无特殊数值问题，标准求根公式x = \frac{-b\pm\sqrt{b^{2}-4ac}}{2a} 能准确求解，误差极小，因为没有出现相近数相减等导致有效数字丢失的情况。
- b^{2}\gg|4ac| 情况（如1x^{2}+100000.0x + 1 = 0 和0.001x^{2}+1000x + 0.001 = 0 ）
当计算\pm\sqrt{b^{2}-4ac} 时，由于b^{2}远大于4ac ，-b与\sqrt{b^{2}-4ac} 数值接近，在做加减法运算（-b\pm\sqrt{b^{2}-4ac} ）时会发生“灾难性抵消” ，大量有效数字丢失，导致计算出的根误差显著增大 。比如在1x^{2}+100000.0x + 1 = 0 中，计算结果x_1 = -0.00001000003385 与精确值偏差较大。
 
替代求根公式（方法2）
 
- 简单方程情况（如1x^{2}+2x + 1 = 0 ）
能得到与标准求根公式相同的准确结果，因为简单方程不存在数值稳定性问题，两种公式在此情形下都适用，误差可忽略不计。
- b^{2}\gg|4ac| 情况（如1x^{2}+100000.0x + 1 = 0 和0.001x^{2}+1000x + 0.001 = 0 ）
替代求根公式x = \frac{2c}{-b\mp\sqrt{b^{2}-4ac}} 在一定程度上缓解了“灾难性抵消”问题。它改变了计算形式，避免了标准公式中相近数直接相减的情况。但由于计算过程中仍存在浮点数运算误差等因素，结果虽比标准公式更精确一些，但仍存在一定误差 ，如在1x^{2}+100000.0x + 1 = 0 中，x_1 = -0.00001000000001 ，相比标准公式结果有改善，但仍不是精确值。
二.数值计算中可能出现的问题
 
1. 灾难性抵消：当两个几乎相等的数相减时，有效数字会大量丢失，导致相对误差显著增大。在二次方程求根中，标准求根公式x = \frac{-b\pm\sqrt{b^{2}-4ac}}{2a} ，在b^{2}\gg|4ac| 的情况下，-b与\sqrt{b^{2}-4ac} 数值接近，相减时就会出现灾难性抵消。例如在计算方程1x^{2}+100000.0x + 1 = 0 的根时，标准公式的计算结果误差较大。
2. 浮点数精度问题：计算机在存储和处理浮点数时，存在精度限制。一些无限小数在计算机中无法精确表示，会进行近似处理，这可能导致计算结果存在一定偏差 。在二次方程求根的各种计算中，浮点数运算都可能引入这种固有误差。
3. 特殊情况处理不当：如二次方程中a = 0 时，方程变为一次方程；b^{2}-4ac < 0 时方程无实根等特殊情况，如果程序没有正确处理，可能导致错误结果或程序崩溃。
 
改进方法
 
1. 采用数值稳定的算法：像二次方程求根，除标准公式外，可使用替代求根公式x = \frac{2c}{-b\mp\sqrt{b^{2}-4ac}} ，它在一定程度上缓解了灾难性抵消问题。还可以通过更复杂的数值稳定算法，如在代码中根据b的正负选择合适的计算方式，避免相近数相减。
2. 高精度数值计算：对于精度要求较高的计算，可使用Python中的 decimal 模块等，它能提供比普通浮点数更高的精度，减少浮点数精度问题带来的误差。
3. 完善特殊情况处理：在程序中增加对特殊情况的判断和处理逻辑。如判断a是否接近0来确定方程类型；计算判别式b^{2}-4ac ，根据其正负判断方程有无实根并给出相应结果，确保程序在各种情况下都能正确运行。

## 附录：核心代码片段
```python
# 这里粘贴关键代码片段
```
标准求根公式函数
 
python
  
def standard_formula(a, b, c):
    discriminant = b * b - 4 * a * c
    if discriminant < 0:
        return None  # 无实根
    sqrt_discriminant = np.sqrt(discriminant)
    x1 = (-b + sqrt_discriminant) / (2 * a)
    x2 = (-b - sqrt_discriminant) / (2 * a)
    return x1, x2
 
 
该函数实现了二次方程标准求根公式，先计算判别式判断有无实根，再根据公式计算两个根。
 
替代求根公式函数
 
python
  
def alternative_formula(a, b, c):
    discriminant = b * b - 4 * a * c
    if discriminant < 0:
        return None  # 无实根
    sqrt_discriminant = np.sqrt(discriminant)
    x1 = (2 * c) / (-b - sqrt_discriminant)
    x2 = (2 * c) / (-b + sqrt_discriminant)
    return x1, x2
 
 
此函数运用替代求根公式求解二次方程，同样先判断判别式，再按公式计算根。
 
稳定求根程序函数
 
python
  
def stable_formula(a, b, c):
    # 处理特殊情况：a = 0
    if abs(a) < 1e-10:
        if abs(b) < 1e-10:  # a ≈ 0 且 b ≈ 0
            return None if abs(c) > 1e-10 else (0, 0)  # 无解或无穷多解
        return (-c/b, -c/b)  # 一次方程的解
    discriminant = b * b - 4 * a * c
    if discriminant < 0:
        return None  # 无实根
    # 使用数值稳定的求根公式
    sqrt_discriminant = np.sqrt(discriminant)
    if b >= 0:
        x1 = (-b - sqrt_discriminant) / (2 * a)
        x2 = (2 * c) / (-b - sqrt_discriminant)
    else:
        x1 = (-b + sqrt_discriminant) / (2 * a)
        x2 = (2 * c) / (-b + sqrt_discriminant)
    return x1, x2
 
 
该函数考虑了多种特殊情况（如a接近0 、方程无实根等），并采用数值稳定的计算方式求根。
 
主函数及测试用例部分
 
python
  
def main():
    test_cases = [
        (1, 2, 1),             # 简单情况
        (1, 1e5, 1),           # b远大于a和c
        (0.001, 1000, 0.001),  # 原测试用例
    ]
    for a, b, c in test_cases:
        print("\n" + "="*50)
        print("测试方程：{}x^2 + {}x + {} = 0".format(a, b, c))
        # 使用标准公式
        roots1 = standard_formula(a, b, c)
        print("\n方法1（标准公式）的结果：")
        if roots1:
            print("x1 = {:.15f}, x2 = {:.15f}".format(roots1[0], roots1[1]))
        else:
            print("无实根")
        # 使用替代公式
        roots2 = alternative_formula(a, b, c)
        print("\n方法2（替代公式）的结果：")
        if roots2:
            print("x1 = {:.15f}, x2 = {:.15f}".format(roots2[0], roots2[1]))
        else:
            print("无实根")
        # 使用稳定的求根程序
        roots3 = stable_formula(a, b, c)
        print("\n方法3（稳定求根程序）的结果：")
        if roots3:
            print("x1 = {:.15f}, x2 = {:.15f}".format(roots3[0], roots3[1]))
        else:
            print("无实根")

if __name__ == "__main__":
    main()
 
